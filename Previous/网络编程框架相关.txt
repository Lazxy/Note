RxJava相关：

理解补充：Observable 是被观察的对象，该对象可以是网络请求任务本体，可以设置自身运行的线程和观察者线程，其在自身任务结束时回调Subscriber的回调函数，并返回其任务结果。两者通过subscribe（Subscriber subscriber）函数连接。

具体地说Observable在创建时需要向create传入一个Observable.OnSubscriber对象（可以视为事件源，即被观察者，RxJava2中是ObservableOnSubscriber对象），该对象需要重写函数call（Subscriber subscriber）（RxJava2以上是subscribe函数，其参数为ObservableEmitter，与subscriber的作用基本相同），该函数调用了观察者的各种回调函数，即掌管了其生命周期，而Subscriber对象是由subscribe（Observer observer）注入的，只有在注入完成后事件源才会开始发送事件。Subscriber是Observer的一个实现类，其比Observer多了一个onStart（）方法，在被注入时调用。

Retrofit与RxJava协同作用时，实际上是直接提供了Observable，也就是封装实现了事件源的实现与反馈方式（所以网络请求的底层实现应该全部都在没有看到的call函数里面），而只留出了Subscriber的回调供处理。

RxJava首先有两个对象:Observable和Observer，前者用于分发与处理事件(或者说响应事件)后者用于监听和处理结果。整个过程是这样的:创建Observable对象，其create函数接收一个ObsevableOnSubscribe作为参数，而该类需要重写一个subscribe函数,其接收参数为ObservableEmitter，其内便说明了分发任务的具体方式。Observable对象可以调用一个subscribe函数，该函数参数可以是一个Observer对象，也可以是某一个类型的Consumer。前者需要重写onSubscribe onNext onError onComplete等监听函数，这些函数会被事件分发处理时调用。后者需要重写accept函数，用于实现某一项监听功能，用泛型加以区分。由于都是内部类传参的调用方式，整个过程可以写成一条链。需要注意的是，事件分发时，onComplete与onError是冲突的，两者不能同时被调用，但前者可以被调用多次，虽然只有第一次调用时被响应。以及当调用dispose时，其后的分配事件全部不被执行。
RxJava的一大功能就是线程的调控，通过设置subscribeOn和observeOn实现，前者设置的是Observable的存在线程，后者是Observer的存在线程，不设置的话两者都默认在各自的创建线程。subscribeOn函数只能调用一次，而observeOn函数能够多次被调用，可以进行不同线程的操作。这两个函数的参数有预设的Schedulers.newThread Schedulers.io ? Schedulers.computation 以及AndroidSchedulers.mainThread，分别对应新线程 IO线程 计算线程和主线程，这些线程都由各自的线程池控制。disposable的用处也在这里体现――如果在子线程任务处理完成之前，主线程已经退出，则事先调用该方法阻止之后信息的接收，避免异常。

map是RxJava中的一个基础转换操作符，其中可以进行一些接收数据的类型转换、排序、归类等操作(还有信息的嵌套递交与操作等，相当于级连一个与之前一致的Observable对象)并将它继续向下传递。其接收和数据转换的类型是由重写的功能函数Function的泛型决定的(类似AsyncTask)。在此基础上，还有一种flatMap，该转换符用于将Observable传来的数据队列分别用独立的Observaeble管道进行数据转换，并最终合成一个管道。其最后的合成是无序的，可能会打乱数据队列的顺序，有序操作应用concatMap。

zip是另一种转换操作符，其作用是将两个不同的Observable对象按接收顺序一一组合，输出一个新的Observable对象。需要注意的是zip的接收参数必须是成对的，当短的一方发完了消息并且调用了onComplete时，它就会终止向下传递信息，即使还有一方的信息未发送完成。
zip一类的操作符会遇到一种情况:两个Observable对象的信息发送速度不均等，就会出现一方的信息堆积，这样的信息都会堆放在BackPress里，就会造成内存的大量占用，甚至出现OOM错误。甚至当单个Observable与Observer不在一个线程时，如果Observer操作相对不及时，也会出现内存溢出。
解决上述问题的方法有几种，在数据丢失可忽略的情况下 可以通过设置filter过滤或者sample采样的方式来减少Observable传递到下面的数据，或者用线程睡眠的方式减慢发送的速度。但这些做法存在缺陷和限制，所以RxJava通过封装Flowable的形式来解决这个问题。
Flowable - Subscriber模式和Observable-Observer模式很类似，区别在于Flowable在create函数中除了FlowableOnSubscribe还有一个参数用于设置BackPress的异常监听方式，并且Subscriber的onSubscribe方法中传的参数从Disposable变成了Subscribtion，其同样也有切断传输的方法cancle，但其还有另一个方法request用于声明其可接收的信息量，以此实现了Flowable模式的拉取式响应，即Flowable只针对Subscription要求的信息量发送信息，当未设定这个参数且两者处于同一线程时，便会抛出异常(该异常会作为参数传给onError,而不会出现Runtime异常)，若两者不在同一线程且接收能力有限时，Flowable的信息将存放在一个128容量的容器中，若该容器溢出，则一样会发生Backpress错误。

事实上Flowable create的第二个参数除了在BackPress发生时抛出error还可以选择填入参数BackPress.BUFFER,BackPress.DORP或BackPress.LATEST，分别指向了三种不同的策略:选择一个无限容量的Buffer存储Flowable的发送数据(此时Flowable与Observable在接收数据能力有限时基本是一样的，也会发生OOM异常)，选择抛弃未准备接收时堆积的Flowable数据，选择保留最新的Flowable数据(也就是最后一个数据一定会被接收)。这样的策略选择同样可以通过onBackPressBuffer(),onBackPressDrop(),onBackPressLatest()三个函数在链中设置。

Flowable 在上游部分(即FlowableOnSubscribe中)拥有与下游request相对应的requested方法来获取下游请求的工作量，随着onNext的调用而减少，随着request的增加而增加。需要注意的是当Flowable和Subscribe在同一线程中时，上下请求是对等的，而当两者异步执行时，则上游会内部调用request方法来设定发送的量(默认为128)，此时下游的request是无效的，并且当下游消费了96个消息时，上游的设定值机制会启动，继续发送信息直到未接收的值达到128。

几种网络编程框架：
HttpUrlClient用法:创建一个HttpUrlConnection,对其进行URL(事实上Connection就是由一个URL对象建立的)、超时时限，接收数据格式等初始化操作，然后connect,通过返回状态值来处理返回信息，信息传递方式为输入输出流。
Volley用法:依赖库
compile'com.mcxiaoke.volley:library:1.0.19’
需要构建一个queue队列(通过Volley类函数得到)，并创建一个类型的request，该构造函数中包括了URL，get或post方式，以及发送及响应的监听事件。然后把这个request加进队列即可获得连接。其回调函数处于UI线程，可以进行界面响应。
OKhttp 用法:依赖库
compile 'com.squareup.okhttp3:okhttp:3.4.1'?
? ?compile 'com.squareup.okio:okio:1.11.0'
先构建一个okhttpclient,然后通过Request.Builder 建立一个request，其中包括设定URL和GET POST方式，然后通过client新建一个Call(参数传入request)来建立连接对象,并通过enqueue(Callback)来设定其回调函数并建立连接(异步,excute是同步),此处的回调函数不在UI线程。其实际上是把初始化连接对象、数据发送对象和回调函数分别做了封装，其封装程度远不如Volley,但由于没有android函数的引入，该框架也能在JAVA开发中用。
Retrofit用法:依赖库
compile ?'com.squareup.retrofit2:retrofit:2.1.0'
Retrofit是OKhttpClient的高级版，它在创建时需要通过Builder，Builder设定了URL参数以及转码工具等各种属性(从GSON、JSON,etc)，并且其在真正建立Retrofit对象时需要其下的client函数(接受一个OKhttpClient对象)来调用build。后面的过程与OKhttpClient一致，同样是通过Call建立连接对象，通过设置Callback设置回调和建立连接。
RxJava 配合Retrofit用法:
compile 'io.reactivex:rxjava:1.1.7'?
? ?compile 'io.reactivex:rxandroid:1.2.1'
RxJava用于实现异步操作，其实现对象为观察者Oberseve和订阅者Subscriber，其中Oberseve可以在重写的call函数中实现网络连接操作并把返回值传给订阅者Subscriber的onNext()函数，并且设置两个对象的线程位置，这样的话就可以让通过addCallAdapterFactory绑定的Retrofit原本处于子线程的回调操作变为由Obersevable设定的Observer在主线程执行。此外，RxJava与其他框架实现不同的点是在Oberseve的链式结构中，可以实现对数据流的预处理(利用map等操作函数)，这样可以将一些常规的类似排序的操作在数据传递过程中完成，达到功能分离。简单地说，RxJava在其中充当了一个数据中转站的作用，它的数据处理和线程调度可以很好地配合Retrofit的操作流程。