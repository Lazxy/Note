2017.1.12
确定实现目标以及步骤。查找了关于模拟点击的实现方式，初步决定尝试RootTools调用Linux底层命令的方式实现事件效果。（但该方式需要取得设备的Root权限，暂弃）
大概还是需要利用AccessibilityService作为辅助工具，触发的TYPE暂定为WINDOW_CHANGED,触发方式为将指示点以窗口方式进行移动和位置变换，在AccessibilityService的处理语句中进行判断窗口移动方式。
遇到的问题：performAction的Scroll相关操作只有向前或向后（每次滚动一下），无法判断水平方向和垂直方向。
猜想：是否能通过测量可滚动控件的长宽比来确定其方向。对BiliBili（tv.danmaku.bili）的测试结果大概是可行的。其一个页面上有三个可滚动对象，依次为ViewPage、RecycleView和一个小型的ViewPage，其长宽比是根据当前屏幕显示的长宽得出的（利用getBoundInParent函数）。然而该方式并不能取代真正的滑动操作，因为类似QQ的抽屉式侧滑栏无法被检测到。以及类似WPS（tv.danmaku.bili）的纸面翻页也不行。
猜想：通过某种方式取得当前页面view 的对象，采用模拟MotionEvent的方式来实现目的。
2017.1.13
继续尝试解决模拟动作的问题。尝试利用反射机制来获得一个当前活动的实例，然后获取其View来模拟点击效果，然而因为反射获得的是一个新的、与当前实例无关的对象，在获取Window处便因为空指针异常失败了。这次尝试的代码如下：
Context context = createPackageContext(event.getPackageName().toString(), Context.CONTEXT_INCLUDE_CODE | Context.CONTEXT_IGNORE_SECURITY);
Class mClass=context.getClassLoader().loadClass(currentClassName);
Object owner=mClass.newInstance();
Object result=mClass.getMethod("getWindow").invoke(owner);
View view=((Window)result).getDecorView().findViewById(android.R.id.content);
view.onTouchEvent(MotionEvent.obtain(SystemClock.uptimeMillis(),SystemClock.uptimeMillis(), MotionEvent.ACTION_DOWN, 100, 100, 0));
发现可以用performAccessibilityAction()来实现四个方向的滑动和定距离滑动。（然而该方法不能从AccessibilityService中调用）
国外有一种解决方案是将程序标记为系统程序，然后通过android.app.Instrumentation包中的函数来实现操作，貌似在6.0以后不能用。同时标记系统程序在不同的ROM中可能也不适配，也无法通过正常的安装过程安装。
暂时先使用AccessibilityService进行一下实现，开始写Camera的部分。
Camera部分大致写完，未测试。
2017.1.14
开始写OpenCV部分，配置了JNI环境，级联分级器目标识别的过程大致写完。
2017.1.15
开始写需要在界面出现的提示用指针，初步想法为在不同情况下以Toast显示不同方向的箭头。
根据其实现方法，设置AccessibilityService的响应Type为WINDOW_CONTENT_CHANGED。
整个简单的框架基本完成。需要测试AccessibilityService中得到的信息是什么样的，然后得到相应的方向描述，并且寻找合适的节点响应事件。
相机在测试中出现问题，基本有两类：一是在图片处理（Yuv图和后面的OpenCV处理）中出现错误，觉得应该跟图片的宽和高相关；二是相机的Surface总是提示为空。但当将窗口调出测试时图像是正确的，但每次都需要点击两次开启服务按钮才能调出窗口。
经过测试得到两次点击调用过两次设置参数的函数时才会出现正常的预览窗口。而这个函数调用的问题出在设置SurfaceView上，当第一次设置该对象时，其大小为（0，0）,直到第二次设置时其值才为（100，100）。
2017.1.16
可能是个别系统原因，代码内申请STYSTEM_WINDOW_ALERT的权限并未成功，这里作一个记录。
原因是第一次调用其SurfaceView时，它的对象并没有被构建出来，构建完成是在调用setPreviewDisplay之后的，中间间隔大概230ms，并且SurfaceView的绘制过程是在主线程中的。
2017.1.17
为了保证窗口的绘制顺利，将窗口初始化和显示过程放在了程序开启的时候。
在获取预览帧时发生错误，觉得出错原因应该是相机像素参数的设定与预计不符。事实证明的确是。
无法检测到人脸，经排查，原因是级联器文件路径有误QAQ。
同样的代码，用笔记本摄像头相较手机摄像头来说稳定的多，但是其图像正置得到的反馈率却没有横置高，非常奇怪。
如果使用放射变化的方法来使得到的预览图摆正，会造成预览图出现一些区域之外的黑色部分，实际上90度翻转只需要用filp函数就行了，注意此时flipCode为0。
左<->上 右<->下
如果没有办法的话，只能用android自带的人脸检测来确定检测范围，然后再确定眼睛的坐标变化了。
android 的FaceDetector定位的眼睛距离还算准确，其得到的中点位置在眉心，可以考虑利用一般人脸比例大致估算出脸的具体位置。
PS:该方法处理的图像格式必须为Bitmap.Config.RGB_565；
2017.1.18
人脸长宽比大概为3：2，双眼间距和脸宽大概也是3：2，眉心大概在脸的下三分之一位置。这样经过换算人脸宽度约为5/3 distance，长度为5/2 distance。
测试得到OpenCV提供的级联分级器中haarcascade_eye的效果最好。但是仍然有垂直变化比不过水平变化的缺点。
在比较暗的环境下，对眼睛的检测可能会错认为鼻孔或者其他暗点，故需要进行一下区域位置判断。
最终还是用广播的方式使信息能够传递到AccessibilityService中。
在向一个方向运动眼球后，应该把下一次反方向的信息忽视，否则会造成反复的来回。
检测方向还是不太稳定，但确定了OpenCV3.0包中的haarcascade_eye文件效果最佳。另，RecycleView貌似不太受Accessibility scroll命令的影响。
2017.1.19
为了提高眼球识别的稳定性和准确度，希望提供一个绝对正确的中点，通过判断相对偏移值来确定方向。（仍然无法达到满意的效果）
尝试采用人脸检测-眼球检测-光流法的方案。
光流法方案尝试失败。测试中特征点的跟踪并不稳定，导致其变化范围极小，不能很好地判断，而且会发生跟丢点的现象。
尝试了绝对化地把左右眼坐标综合起来判断，仍然无法达到预计效果。
想要给窗口指针加上动画，但窗口的可用动画只有出现、消失、隐藏、显示时的动画，进一步设置动画需要给窗口中的View一个父布局，不能直接提供。
2017.1.20
对图像处理过程进行了函数拆分，稍微尝试优化了其内存占用（降低了计算频率）。
即时预览可以看到对眼球的识别其实还是相对精确的，但是因为其固有的抖动和眼球本身运动范围的限制，很难将其轨迹归结为一个可靠的方向。
开始做应用开启界面动画 初期思路为自定义一个SurfaceView，也放在IndicatorWindow中，其大小设置为正好覆盖住开启服务的按钮，在进入应用时初始化，开启服务时睁眼，将其隐藏和显示的命令写在MainActivity的生命周期里，而绘制的命令写在setDirection函数中。
2017.1.21
关于Surface绘制不出图像的问题，原因是画笔颜色为RGBA格式，即透明度是一定需要设置的，否则会造成画笔完全无颜色。
注意Canvas的drawArc（Rect rect,float startAngle,float sweepAngle,boolean useCenter,Paint paint）方法参数依次为被截取椭圆的外接矩形、截取起始角度（注意其坐标轴以三点钟方向为起点，顺时针截取，六点钟方向为正九十度）、截取角度范围（注意不是中止角度）、是否连接圆心以及画笔。
用点遍历算法把眼睛轮廓填充的问题解决了，但是不知道为什么会有两条线出现问题。或许还需要为眼睛下方补充一个阴影。明天开始把动画全部做完。
2017.1.22
又一次出现了addView的时候surface没有绘制完毕的情况。尝试了在命令绘制后加while循环判断、线程睡眠等方法，都没有解决这个问题。
= = 发现在用drawColor函数时，其界面更新是即时的，根本不需要自己调用update函数。
图像没办法绘制出来的原因是画布中的坐标都是以当前画布范围为坐标系范围的！！我要疯了。
holder.setFormat(PixelFormat.TRANSPARENT);可以设置画布透明。
通过为SurfaceView设置ViewGroup及其子类的Params（例如RelativeLayout、FrameLayout等）,可以设置SurfaceView在Window中的对齐方式等。
当窗口的大小大于SurfaceView大小时，整个SurfaceView会被拉伸到窗口大小。
2017.1.23
在程序打开时activity会调用onPause（），原因可能是因为窗口的创建使其感到被遮挡，用一次性的判断变量解决了，但觉得可能是一个偶然性的问题（比如其他程序显示在上层使之被调用），在此记录。
需求：左箭头向左边移动（实际是右滑，也就是backforward），右箭头向右边移动（实际是左划，也就是forward）而用来处理的图片是左右相反的，也就是当x值大于0时，眼睛向左，此时是左箭头，x值小于0时是眼睛向右，右箭头。
在为服务设置前台服务时，发现在5.0以上版本的机器中无法像4.4版本时一样直接用RemoteView。
2017.1.24
修改了MainActivity销毁后眼睛无法显示的问题。封装了一个运行时权限工具类。学习了集合的排序方式（用Comparator方式）。
2017.1.25
找到了一个看起来还可以的ViewPager实现方式（但没有解决内存问题），在获取当前点击图片的页面上还有些问题，另外，设想中的触屏事件分发方式是根据PhotoView的getScale()函数来判断的，即是否为1.0f。
2017.1.26
利用一种比较粗糙的方式，算是把ViewPager和PhotoView结合了起来，但是内存占用量实在是很大，并且出现了进入ViewPager时总处在第一页的情况。
发现onScroll监听到的只有左右滑动的手势，事实原因是并未对整个ScrollView设置监听，而仅对图片设置了监听。
RemoteView不显示的实际情况是其文本都被改成了白色，在背景下无法被看见，原因大概是设置了不被允许的格式。（然后突然又不能用了，很神奇）
startForeground方法设置的Id不能重复，否则无法推送到通知栏，不会有任何显示。
可以通过设置<meta-data android:name="android.support.PARENT_ACTIVITY" android:value=".XXXActivity">的方式来为活动设置返回操作后到达的Activity。也可以通过TaskStackBuilder.create()创建返回栈 addParentStack()将返回栈加入堆栈，addNextIntent（）添加相关Intent，并用getPendingIntent()来获得可以放入通知的PendingIntent。
而当希望PendingIntent点击进入的是一个空任务（点击返回直接回到主界面）时，可是通过对Pending Intent构建时的Intent设置Intent.FLAG_ACTIVITY_NEW_TASK| Intent.FLAG_ACTIVITY_CLEAR_TASK)，并在Manifest标签中对相关活动加上android:taskAffinity="" android:excludeFromRecent="true"，就能实现所要的效果。
2017.1.29
修复了一下Len中搜索数据库有遗漏的问题，原因是因为移动cursor时先做了moveToNext（）操作而导致第一行被忽略，用do while的方式代替。
遇到了FloatingActionButton无法实例化的问题，最后解决问题的方式是clean整个项目。
用在onPrepareOptionsItem（）中设置图标可见与否的方法，可以动态修改Toolbar的图标，其触发方式为调用invalidateOptionsMenu（）函数。
Toolbar中的overflow窗口是否覆盖图标的设置在android 5.0以上才有，低版本如何处理未找到解决办法。
Toolbar的Title永远处于Toolbar居中的位置，而其图标位置貌似是固定在一个位置上的，在不同的高度下两者可能不对齐。
2017.1.30
Activity向Fragment传数据时，可以用setArgument的方法传一个Bundle数据，而Fragment回调数据时，可以通过getActivity().setResult()的方式传回所需要的数据。
当碎片的显示没有特殊的要求时，可以采用抽象出一个Activity基类，在onCreate中设置碎片的布局位置和开启事务、提交等过程，另提供一个创建不同Fragment的抽象函数，这样其他Activity只需要继承该基类，复写抽象函数并直接继承onCreate函数，就能够达到共用一个布局文件并复用代码的目的。
当Fragment间需要传递数据时，可以采用setTargetFragment()的方法将当前Fragment对象传递到下一个Fragment，然后手动调用onActivityResult()函数将数据传回。
再开启事务到提交事务的链中，可以进行诸如设置动画之类的操作。
一个问题：从代码上来看ViewHolder并没有新建对象，列表绘制的过程是对布局的多次替换重用那，为什么列表中View的属性和Tag都能保存下来？
2017.1.31
突然想到，LookAtMe没有考虑到其他的相机应用或者电话应用抢占硬件资源的情况。
考虑在5.0以上用UseageStatsManager来检测应用使用时间，初步测试可行。5.0以下版本的就只好采用原服务定时遍历当前进程的方案了。
2017.2.1
测试了采用getRunningAppProcesses的方式获取当前的显式进程，效果勉强还行，但该方法会获取一些系统程序进程以及system这一系统进程，需要进行一下判断处理，类似流量监控器之类的悬浮窗反而对其没有影响，关闭屏幕后其获取依然，但锁屏后前台进程就成了锁屏进程。
由于要实现分时段显示的功能，需要将数据库中的数据加以时间标识，其存储格式为Integer，取出方式为long，存入的值需要预先处理为某日的0点0分0秒。
基本上将功能实现涉及到的包操作和数据库操作编写完毕，但笔记文件存储方面还未完成，拟采用getApplicationContext.getFilePath()获取程序私人文件夹来作为文件存储路径。
2017.2.2
初步测试了即时监听程序开闭的服务，效果还可以。
在自定义控件中可以自定义属性，其声明可以写在attrs文件中，声明方式为：
<declare-styleable name="notepad">	//name可以任取
      <attr name="line_color" format="color"/> //当直接使用系统已定义属性时，只需要写 name="android:color" 不需要写format
</declare-styleable>
调用时在layout文件中加上命名空间xmlns:xxx="http://schemas.android.com/apk/res/com.li.xxx" 即可调用赋值（实践中发现直接用res-auto的命名空间也可以，一般为app）
而在自定义类中，要通过context.obtainStyledAttributes(attr,R.styleable.notepad)方式取得TypeArray对象，再以getXXX(R.styleable.notepad_line_color)函数获取具体value（此处XXX取决于format)。这些属性其实也可以通过attr.getAttributeValue(index)来获得，但它获得的是直接值，若其属性是通过@方式从value中引用的，它会返回在R文件中的int值，styleable声明实际上就是为这些int值单独封装了类，以TypeArray调用，省去了int的转换过程。
标准EditText无设置最长字数自动换行功能，需要设置内容监听。但是可以通过禁用横向滚动和禁用单行输入来达到长度超出界面宽度时换行的效果。
2017.2.4
setInputType(InputType.TYPE_TEXT_FLAG_MULTI_LINE);认为这行代码的实际作用是让单行输入区域内能自形成一个纵向滚动区。
在EditText外包裹ScrollView可以使其在键盘弹出时自动向上移动以显示出底部内容。
今天大概写完了EditText和File部分，明天可以开始准备写各个碎片和按钮功能部分了。
2017.2.5
初步确定各个碎片和界面的出现方式的布局，学习熟悉了RecycleView的基本用法。
2017.2.6
遇到一个很奇怪的问题：TextView以alignParentTop的方式对齐时，会造成整个RelativeLayout的整体下移，而当设置了paddingTop为一定值时，该现象消失，反而与RelativeLayout并列的控件下移了。而设置并列控件的padding时，造成了RelativeLayout的位移。最后没有办法只能固定了各个控件的宽度，将线性布局改成了绝对布局。
fitSystemWindow可以使布局范围拓展到ActionBar的部分，但无法对该部分进行操作，只有将主题设置为NoActionBar才能自定义Toolbar。
android的主题大概与H5的css设定类似，设置全局主题时可以在application标签下设置主题，而为activity或者view设置主题时会复写与全局主题相同的属性部分，并添加不同的部分。并且对view的layout_width之类已有属性可以作为item写在一个主题中，让应用设置该主题时则属性设置也就完成了（估计默认原来的样式就是默认主题的效果）。@符号可以用来调用本次定义的属性，？可以用来调用主题中默认定义过的属性。
今天大概写完了AppInfo的界面部分，待测试。明天可以开始写NotePad的目录和编辑界面逻辑了。大概会有多余的时间，可以来写Activity逻辑了。争取元宵前完成整个应用。
2017.2.7
可以编辑单个控件的theme后将其作为一个Item写入Activity Theme的参数，如<itemname="android:popupMenuStyle">@style/Theme.PopupMenu</item>
CoordinateLayout的一点记录：
layout_scrollFlags中的几个值：
scroll:将此布局和滚动时间关联。这个标识要设置在其他标识之前，没有这个标识则布局不会滚动且其他标识设置无效。
enterAlways:任何向下滚动操作都会使此布局可见。这个标识通常被称为“快速返回”模式。
enterAlwaysCollapsed：假设你定义了一个最小高度（minHeight）同时enterAlways也定义了，那么view将在到达这个最小高度的时候开始显示，并且从这个时候开始慢慢展开，当滚动到顶部的时候展开完。
exitUntilCollapsed：当你定义了一个minHeight，此布局将在滚动到达这个最小高度的时候折叠。
snap:当一个滚动事件结束，如果视图是部分可见的，那么它将被滚动到收缩或展开。例如，如果视图只有底部25%显示，它将折叠。相反，如果它的底部75%可见，那么它将完全展开。
事件产生源需要设置 app:layout_behavior:="" 其value可以是系统的已有定义，也可以是自定义Behavior。
Toolbar的点击事件设置可以在OnOptionsItemSelected中或者OnMenuItemSelected中，后者需要在设置supportActionBar后再设置监听。其左上角返回键的id为android.R.id.home。
由于位数不够的原因，当两个应用的开启时间都非常短时，可能会出现一些排序问题，暂且搁置。
= = 一口毒奶。今天刚刚写完Note目录部分。明天写EditText的Activity逻辑和完成主Activity的逻辑。
2017.2.8
在CoordinatorLayout中，当AppbarLayout中的Toolbar声明协作flag并且其他控件响应其触发事件时，其他布局会自动处于AppbarLayout下方，否则会按照一般FramLayout布局对其进行覆盖。
用SwipeRefreshLayout可以实现下拉圆球刷新的效果。
getFragmentManager（）取得的FragmentManager与getSuportFragManager()取得的对象应该是父类与子类的关系，前者不能调用getFragments等方法。
一种实现碎片嵌套回退的思路：写一个BackPress监听的接口，接管Activity的onBackPress，事件发生时遍历FragmentManager的所有活动碎片，层层向下，若有子碎片实现了这个接口，则将事件执行权赋予该碎片，否则返回给Activity执行，类似点击事件的处理机制。
调用split函数时，要注意"."和"\"作为转义字符需要写为"\\."和"\\\"
CardView_cardBackgroundColor 设置背景色
CardView_cardCornerRadius 设置圆角大小
CardView_cardElevation 设置z轴阴影
CardView_cardMaxElevation 设置z轴最大高度值
CardView_cardUseCompatPadding 是否使用CompadPadding
CardView_cardPreventCornerOverlap 是否使用PreventCornerOverlap
CardView_contentPadding 内容的padding
CardView_contentPaddingLeft 内容的左padding
CardView_contentPaddingTop 内容的上padding
CardView_contentPaddingRight 内容的右padding
CardView_contentPaddingBottom 内容的底padding
不能在Activity退出时创建Dialog，这样极容易造成窗体泄露异常。
遗留问题：Fragment重复加载，从编辑界面退出时目录界面未更新。当文字多时从目录进入正文页会有卡顿（这个其实还好）。预想中的文字滚动标题栏和悬浮按钮都隐藏的效果没有出现，编辑页悬浮按钮需要设置成点击编辑后便成为保存按钮。
一个Tip：在恢复被禁用的EditText焦点时，调用 notePad.setFocusableInTouchMode(true);（调用notePad.setFocusable(true);无效）然后再调用requestFocus()才有效。
2017.2.9
当一个Fragment被create的时候，另一个Fragment会开始依次调用onPause、onStop、onDestoryView、onDestory，但仅是Hide时不会有销毁过程。
定义BottomSheetBehavior可以实现布局折叠效果。
ScrollView和CoordinatorLayout有冲突，需要用NestedScrollView取代。上划隐藏Appbar时会出现覆盖状态栏的问题，此时应该取消fitSystemWindow，但于此同时状态栏颜色会消失。
基本把前戏都做完了。休息一下晚上可以开始写SurfaceView部分了。
整个沙漏动画应该分为两个部分，上半部分绘制动态波形，下半部分同时绘制动态波形与下漏效果。两边都采用沙漏形状的遮罩，遮罩形状为(0.01x)^3。
通过设置android:background="?android:attr/selectableItemBackground"或
android:background="?android:attr/selectableItemBackgroundBorderless"可以使控件点击产生水波效果
或者通过<ripple>标签进行定义，此时其必须设置drawable且id必须为android:id="@android:id/mask"（颜色由color而不是drawable决定）
Canvas绘图部分仍然需要从头开始学起，明天务必要将其原理搞清楚。
2017.2.10
因为Integer位数不够会导致查询周期为Month时报错。并且注意Adapter数据源的引用问题，这是一个无法更新当前列表的原因。
Eyes动画修改备注：尝试用Picture保存眼眶，用图层绘制眼皮。
canvas.saveLayer保存的是之后绘制的那层。SRC指当前要绘制上去的图像，DST指原有图像。不知为何只有调用过saveLayer后才能有混合模式效果。
canvas无法为直线设置画笔为FILL形式。
历尽千辛万苦画出来一个沙漏。。明天回来希望能把动画做做完。
2017.2.11
波纹效果完成。明天做沙漏动画以及碎片嵌合，别忘了增加删除当前任务的功能。
2017.2.12
如果在onCreate中初始化一个View，那么其会依次调用构造函数、多次调用onMeasure、onLayout,然后调用一次onSizeChanged完成从0到指定值的初始化过程，最后再调用onMeasure和onLayout。而且这个过程和onCreate的执行过程异步的，怀疑是在onStart之后执行的。
主题内容大致完成，接下来需要修复的BUG有：滑动切换碎片问题，数组内容异步被修改造成的运行时异常。以及要补充的一些UI内容，见注释。
2017.2.13
在OnTouchListener处理点击事件时，需要在ACTION_DOWN事件后return true，否则无法进行下一事件的接收。
将equals直接用于int与String的比较时，会出现BUG，必须把int先转化为String型。
在主线程更新UI果然够呛，需要让hourglass继承SurfaveView才行。明天继续改吧。
2017.2.14
今天要解决的问题有：SurfaceView显示问题，AppInfo的同名归类问题，以及倒计时文字的调整。
DirtyRect可以实现刷新界面局部。当用SurfaveView呈现动画时，一定要在其关联窗口前设置ZOrderOnTop,这样画布显示其固有颜色，而非通过设置根窗口透明度显示动画使得背景为不可改变的黑色。但这样做以后，该View就会永远处于最前端，遮盖除了浮动窗口以外的所有View。。