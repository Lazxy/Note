---
title: C++笔记
date: 2018-07-09 14:04:00
tags: 笔记
---

> C++，我可能永远都学不会的语言OTZ。应该是当年做毕设的时候折腾的成果，看的大概是《Accelerated.C++》，希望哪天能重新学完。

#### Chapter Zero

​	导入依赖库 `include <XXX>`(标准库) 或者`include 'XXX'`(当前路径下的文件);main函数的返回值，0表示执行无异常；命名空间是一系列相关声明名字的集合，用`XXX::`表示引用XXX命名空间内的名字；`<<`输入输出运算符接收两个参数，一个是**std::ostream**类型 如std:cout 另一个是一个String类型，并返回第一个参数； C++函数体内**空代码块{}的存在是合法的（Java其实也合法）**；段注释之内不能有其他的段注释结束符，如/\*/**/\*/，且段注释前不能有行注释；

<!--more-->

#### Chapter One

​	可以通过`std::cin >> `的方式从标准输入获得字符串；字符串需要导入\<string\>包才能使用；从标准输入输入字符串时，其数据实际存储在缓冲区里；缓冲区刷新的条件有三种：缓冲区满、存在读的行为和显示刷新；可以用`+`来连接两个字符串，当一个操作符可以对不同类型的操作数起作用时，该特性称**重载**；可以用`const`修饰常量，**其中 `int * const p`称常量指针，其指针值（即指向的地址）不可更改，而`const int *p`称指向常量的指针（或者指针常量）,其指向的地址上存放的值不可更改**；string 的其中一个构造方法是传入一个int型i和一个char型c，构造出一个有i个c的字符串； **~~C++的构造没有new关键字~~当本地方法与构造名冲突时，会报编译异常。（Kotlin中相同情景的处理方式是直接调用本地方法）**

#### Chapter Two

​	C++的while、if和逻辑符号（包括左移<<和右移>>这也是一对重载操作符）都和Java一致；可以用`using`语句声明导入命名空间，如using std::cout，且支持局部导入命名空间；其基本数据类型的大小根据编译器和CPU位数而定，一般int为32位，最低为16位，long为64位，最低为32位；布尔型变量在C++为bool；

> 关于C/C++的移位运算：移位时，移出的位数全部丢弃，移出的空位补入的数与左移还是右移有关。如果是左移，则规定补入的数全部是0；如果是右移，还与被移位的数据是否带符号有关。若是不带符号数，则补入的数全部为0；若是带符号数，则补入的数全部等于原数的最左端位上的原数(即原符号位)。

#### Chapter Three

​	可以通过**cin >> XXX >> XX**的方式连续获取输入的字符，等同于cin >> XXX; cin >> XX;在cout的<< XXX <<中，可以直接用**空格将两个字符串（只能是带引号的常量）隔开然后输出**，其效果等同于用+将两者连接；字符串与bool型变量初始化与Java一致，但其他**基本类型不会初始化为0**，但可通过编译；\<iomanip\>包下的setprecision方法可以设置标准输出的有效位数，而导入\<ios\>包可以调用`streamsize`类型，它表示了前面precision值的类型，可以通过`cout.precision()`获得具体对象；C++延续了C**通过值是否为0直接进行判断（非0为true）**的性质，相似的`cin`的类型`istream`也可以用来作为判断条件，为true的条件为cin上次读取流成功；`vector`是C++中的Stack实现，其访问方式类似数组（通过[ ]）表示大小的数值类型为`size_type`（实际上是起了别名的无符号整型）；可以用`typedef`来对类型进行重命名；导入\<algorithm\>包后，可以直接调用sort方法传入排序范围对`vector`进行排序；

#### Chapter Four

​	C++默认的参数传递是**值传递（只复制传值不传地址）**，改变形参的结构或者值不会影响实参，但也可以选择设置形参类型为XXX&(如vector\<int\>&)，则此时为**引用传递**，但注意此时传入引用的对象必须不为临时对象（比如一个函数的返回值），或者说其对象必须是一个**lvalue（被声明的变量）**；异常机制所在的包为`<stdexcep>`，边界溢出异常在这里为`domain_error`，try-catch 用法与Java基本一致，除了catch()内的异常直接传入异常类型（如catch(domain_error)）；当cin在输入流的过程中发生了错误（如类型输入错误）或者到达文件末尾，可以用`cin.clear()`清除状态，并用`cin.ignore()`清除缓冲区内容（否则可能引起另一次输入错误）；函数在调用前必须先声明（在main之前）；可以**直接将定义的函数名作为函数的指针传入其他方法中作为参数**（比如sort中的compare参数），该处与Kotlin中需要以`::`声明方法引用的方式略有不同；string的大小可以直接进行比较（同Kotlin，但Java只能用compareTo比较）；`max`之类的函数必须保证其参数类型一致，如size_type与int不能一起传入max来进行比较；**封装自定义函数**的方法主要是构造一个新文件写上函数内容并为其配置一个.h文件，再在调用该函数的主程序中`#include "XXX.h"` ，此时头文件应处于调用方相同工作目录下，或者在引用时写全路径（**在C-Free中需要新建一个工程并将这些文件放入合适的文件夹中才能生效**）（另：就头文件预声明函数的作用来看，与Java接口功能有些相似之处）；**在头文件中最好不要用`using`语句**，以避免源文件中的引用错误；C++中也存在内联函数，一般声明在头文件内；

> 在这里需要注意常量引用与一般引用的区别：用const修饰的引用（如const vector\<int\>&）既不能修改引用对象（和Java一致）也**无法修改该对象内的值**，此时其内的值是只读属性的。并且常量引用无法再给非常量引用赋值，可视为在常量引用的创建过程中建立了一个访问保护封装，会拒绝非常量引用的访问请求。但在这种情况下**可以将作为临时对象的实参传入作为形参**。 

#### Chapter Five

​	类似Java的集合，vector也有`iterator`成员变量，其类型有两种：指向对象可变的`vector::iterator` 和 指向对象不可变的`vector::const_iterator`，其实际类型**类似一个指向vector泛型对象类型的指针**，可以通过vec.begin()等方法赋值； 可以通过`iter -> params` 的方式代替`(*iter).params`的调用成员变量的方式，这是一种语法糖；C++中对迭代器迭代过程中的数据结构变化有与Java相似的失效机制，不过其采用的方法为让修改了数据结构的方法（如`erase`）返回新的迭代器；C++中的链表实现为`list`，其位于\<list>库中，大部分方法与vector一致；list的**增删方法由于实质上并不影响整体的迭代器遍历，故在这两种情况下其相关迭代器不会被全部重置**，被重置的只有指向当前被删除对象的迭代器，这是与vector的主要区别；list本身由于无法随机访问不能通过全局的`sort`方法进行排序，但其自身定义了专用的`sort`方法；`<cctype>`包内定义了跟字符串操作相关的方法，诸如`isspace`和`substr`等；

#### Chapter Six

​	`<algorithm>`是C++的标准算法库；**对于一个指针类型的值，`a = b`与`*a = *b`是等价的，并有`*a++ = *(a++)`，即*的优先级低于自增运算符**；`find_if`方法接受三个参数，两个迭代器和一个方法(用于声明匹配条件)，用于查找迭代器范围内匹配条件的引用，查不到则返回iter.end()；可以用`rbegin`方法得到反向遍历的迭代器，以此来检查回文；`static`关键字在C++中的用法为，修饰方法的本地变量，从而只在第一次调用该方法时初始化该值，后面的调用都直接调用首次初始化之后的值；库中的`find`方法相当于Java的`indexOf`；`search`方法相当于Java的`contain`，不过此时字符串都用一头一尾两个迭代器表示；**迭代器允许`iter[-1]`这样的表示方式，其相当于将指针指向迭代器当前位置的前一位,实际表达了*(iter - 1)的含义**，所有可以用角标表示的类型都有迭代器性质；`back_inserter`方法的作用为返回一个指向标准容器的迭代器，所有对该迭代器的操作都会直接将新增的值插入到容器末尾；`transform`方法类似于RxJava中的transform操作符，分别传入一个可迭代对象的首尾两个迭代器、目标容器的迭代器（需要保证该容器有足够的空间）以及一个转换函数，即可实现可迭代对象的所有内容的转换并存入目标容器；`remove_copy`方法的作用是将指定区域内（用首尾两个迭代器表示）的指定数值（第四个参数）删除，并将剩余值复制入指定的容器（第三个参数表示），类似的还有`remove_copy_if`等拓展方法，其实现更为复杂，需要和`erase`类应用一同实现达到需求的效果；`partition`方法可以对两个迭代器所指区间进行判断条件为第三个参数的区分，符合条件的提到容器前半部分，并返回第一个不符合条件的值的迭代器指针；

#### Chapter Seven

​	C++的`<map>`包中也有查找表的实现，其用法和vector很类似，可以直接通过map_name[x]的方式获取键x对应的值，需要注意的是map作为容器存储的数据类型为**pair**，其`first`属性中存储着常数形式的键，而`second`属性中存储着值，声明类型时需要写pair\<const x, y\>;当两个泛型括号连着写时，需要在中间加个空格以示与`>>`操作符的区别；C++可以有**默认的函数参数**，设置时书写方式例如int addOne(int x, int y = 2)；当需要一个方法被作为参数传入另一个方法时，只需要在声明方法时写明方法的返回类型和参数列表，并给其起一个别名即可，如：

```c++
int higherFun(int lowFun(int x));//这里lowFun是传入方法的别名
```

**当利用map索引一个不存在键的值时，map会为该键新建一个键值对**，其值为值类型的初始化值；可以用map的find方法寻找是否存在指定键的值，如果存在则返回指向该pair的迭代器，否则返回map.end()；\<cstdlib\>中有获取随机数的实现方法rand()，其会返回一个0-RAND_MAX范围内的int；C++的标准查找表实现不是HashMap，但其有**自动排序**功能，更方便于迭代器迭代。

#### Chapter Eight

​	C++中泛型的使用与Java十分类似，在使用泛型前需要声明`tempate<class T>`，当泛型在实现时出现错误（如用了未重载的操作符）时，会报编译时异常（对比Java，Java会直接不允许未指定父类型的泛型运用一切其他操作符），当泛型不在参数列表中时，需要在调用方法时显式表明泛型类型；容器的`end()`方法一般会返回一个指向最后一个对象的下一个位置的迭代器，这是为了便于越界状态的比较和书写，并避免对最后一个对象指代不明的情况；可以用`istream_iterator`和`ostream_iterator`对输入输出流进行封装，来进行容器内数据的读入和写出；

#### Chapter Nine

​	C++中允许在结构体中声明方法，并在结构体内声明（此时方法视为一个变量，需要在`}`后加`;`）或者调用结构体的类中进行实现，后者**需要以`结构体::方法`的方式进行实现声明**，且可用方法声明后加`const`的方式声明不允许在此方法内修改结构体的变量；在实现某结构体或类下的成员方法时，如果需要调用其它的同名方法，需要用`::方法名`来声明调用的不是该类内的方法，否则会抛出参数异常；**struct** 和 **class** 定义的类的**区别**主要是：前者在没有可见性声明的情况下，默认可见性为`public`，而后者默认为`private`；在类（或结构体）的默认构造中，**引用类型会自主调用默认构造初始化，而不像Java一样为null，但基本数据类型~~会被随意分配一块内存，~~其值不确定（在不用new构造时其不会被分配空间，值随机；而用new构造后会顺便对分配的空间进行初始化）**；构造的书写方法为：`类名::类名(参数列表):成员变量(初始值),...成员变量(初始值) {构造语句}`。

#### Chapter Ten

​	0是唯一一个可以转化为指针类型的整型；可以用 `int *p` 或`int* p`两种方式来定义一个int型指针（当然所有类型都一样），而对于类似`int* p,q`的语句，其等价于`int *p,q`，即先定义一个指针，后定义一个整型；**当声明一个方法指针时，其格式应该是这样的:`int (*fp) (double);` 其中int表示方法的返回值，fp表示指针名，double表示方法的参数类型**；在赋值方法指针时，**可直接用已有的方法名赋值，或以`& + 方法名` 的方式赋值，这两种格式是等价的**；同时调用方法指针时，**可以用`指针(参数)`的方法进行直接调用，也可以用`*指针(参数)`调用，这两种格式同样等价**；在方法指针作为参数列表内参数声明时，可以用上面的定义声明格式，也可以省略`*`直接在中间写上方法指针的名字（假装是直接传了个方法进去）；**当需要让方法指针作为返回值时，需要先通过`typedef`定义一个方法指针变量类型**，然后在方法中返回这个类型；所以下面的代码是可以实现的：

```c++
typedef int (*getInteger)(double i); //自定义方法指针类型,这个指针名不能和方法名一致
//原始方法
int getInt(double i){
	return (int)i;
}
//获取方法指针的方法
getInteger getGetInt(){
	return getInt;
}
//通过获取方法指针获取原始方法作为参数的方法
int transDouble(int (*getGetInt())(double))
{
	return (*getGetInt())(5.6); //这里*getGetInt() 实际上就是获取到了getInt的方法指针
}

int main()
{
	cout<<transDouble(getGetInt)<<endl; //所以这里要传入获取方法指针的方法
}
```

数组的长度不能同其他类类型数据结构一样用`size_type`表示，其长度类型为`<cstddef>`中定义的无符号整型`size_t`，同时该库中还有一个类型称`<ptrdiff_t>`，其表征了两个指针间的距离；**C++的数组是越界合法的**，其越界时指针会访问响铃内存，得到一个随机值；字符串相当于一个在末尾多加了一个`'\0'`的字符常量数组；`sizeof`方法用于检查对象的占用内存大小，单位为字节；与`cout`类似，`clog`与`cerr`同样表示相应的流，区别在于`clog`同`cout`有缓冲区，只在条件满足时输出流，而`cerr`会**立刻输出**输入的流；对于文件的输入输出流，其标准库为`<fstream>`，相应的流为`<ifstream>`和`<ofstream>`，这两个流初始化时接收一个**字符数组的指针**作为参数，而不用`string`，且表达式格式为"流类型 + 变量名(文件地址)" ，如：

```c++
ifstream infile("E:\\text.txt"); //这里的infile就是变量名
```

关于内存管理，C++支持三种内存管理方式：1. 系统自动分配和释放内存，多见于本地变量的声明和代码块结束后对资源的释放；2. 用**new**关键字构造一个对象并返回指向该对象的**指针**（在这个过程中无论是对象类型或者基本数据类型都会被初始化，包括数组，但**数组的元素如果是基本类型，仍然会是随机的**），用**delete 指针**的方式释放该对象（对数组用**delete[] 指针**）；

#### Chapter Eleven

​	由于需要预先分配空间，所以C++的类对象在声明时一定要被初始化，并且允许直接用构造方法参数赋值的方式直接初始化，如：

```c++
Object o; //此时调用了Object的无参构造进行初始化，如果默认构造不存在，则编译会不通过。
Object o = 5; //相当于调用Object(5)，这种调用方式只能针对有一个非默认构造的对象使用
//以上相当于对构造的隐式(implict)调用
```

而**explicit**关键字的作用就是禁止默认的隐式调用，而要求必须显式地写出构造；通过**typedef**重定义类内的一些类型，可以增加程序的可读性，同时隐藏其原始实现，便于之后的替换；**this**这个关键字在C++中并不是一个对象，而是指向自身对象的指针，故其调用成员变量时应该写为`this -> member` 或者 `(*this).member`；类对运算符的重载，示例如下：

```c++
float operator [运算符符号] (int value1,int value2){...} // 其中float为运算返回值类型，value1为运算符左边的值（当该运算符由类对象调用是，可忽略该参数），value2为运算符右边的值，函数体中需要返回一个值
```

C++中对构造方法进行了更多细分，其中之一就是复制构造，其声明如下：

```c++
//在Clz类中
Clz(const Clz& c){...} //构造的方法名和参数类型都与类类型一致，且参数为常数，保证不修改原对象
```

需要注明的是：C++的对象复制其实在大多数情况下是依靠对赋值运算符`=`的重载实现的；作为一种语法糖，在头文件中定义带泛型的雷星时，可以忽略`<T>`的写法，只在调用时显式声明；当在方法中定义本地对象时，若return该对象的引用，则调用方得到的引用应该指向一块随机内存，因为对象在方法结束时会被释放空间（在Demo的尝试中没发现这个问题，**待研究**）；可以通过直接填入构造参数的方法构造对象（对无参构造不起作用），如：

```c++
Clz c(parm1); //构造一个Clz对象

Clz c; //顺便 貌似不需要显式调用构造也能调默认构造构造对象
```

与构造方法相对应的，C++中存在用于释放内存的**析构方法**，其无返回值也无入参，声明如下：

```c++
~[ClassName]()
{
	//对内存的释放  
} 
```

基本数据类型（包括其指针），在初始化、赋值的时候会进行**值传递**，而析构此时不起作用；引用类型对象则会在初始化、复制或赋值时调用相应的操作符和操作方法（未指定则由系统默认提供），并在销毁时调用析构；上面提到的对象操作方法总结如下：

```c++
T::T() //构造方法
T::~T() //析构方法
T::T(const T&) //复制构造
T::operator=(const T&) //分配（赋值）操作符重载
```

> [Rule of Three](https://stackoverflow.com/questions/4172722/what-is-the-rule-of-three)，指当需要自定义析构方法时，也必须自定义复制构造和分配操作符，否则可能发生重复释放同一块内存或者内存泄漏等问题，详细解析见链接。

由于C++自带的`new`关键字会在分配内存的同时初始化对象，故不适合直接用在对象数组的定义时，此时可以使用**\<memory\>**库来分步进行对内存的分配、构造和销毁等操作；`delete`方法可以对空指针进行操作，而`deallocate`只允许对指向已分配空间的指针进行操作；

#### Chapter Twelve

​	对于未赋值的类成员常量、引用或者没有默认构造的对象，需要通过构造前赋值的方式来进行初始化，否则编译会报错（这也验证了上面说到的在一个对象初始化时其持有的其他对象也会递归的被初始化），如：

```c++
public:
const int i;
Obj o; //无默认构造的对象
Demo::Demo():i(0),o("initialize") //必须用“变量名（参数）”的方式进行初始化
{
  //...
}
```

当然，针对对象的情况，也可以用指针来代替直接持有对象的引用，这样可以避免连续初始化；C++可以通过声明友元函数来对某些方法开放其私有变量的访问权限，以方便其他类的对其的读写，如：

```c++
friend std::istream& operator>>(std::istream&, string&); //string对参数为输入流和字符串引用的“>>”符号重载开放私有权限
```

如果一个**二元操作符**作为一个类的**成员方法**重载，则该类的调用方**不允许是一个自动转换过的类型**，这就限制了编译器在编译时的选择（不再需要考虑该类型之外的操作符重载）—— 相对的，当该操作符不在类内定义时，其调用方可以是任意满足条件的可自动转换类型（这两种情况下，被调用方都是可以为自动转换类型的）；当一个类的构造方法中**参数仅表示对象结构相关的属性**时（比如数组的大小），该构造应该用`explicit` 来显式表示，否则其可能会由于自动类型转换造成实现错误，而当参数值表示其内容时，则允许隐式表达；自动转换类型的方法也允许被显式重载，其格式为：

```c++
operator [转换后的类型]()
{
  //...
}
```

正是该重载，使得类似istream之类的类型，能够在if语句中自动转换为void*类型，并接着转换为bool类型。

>   书中最后一段提到了，如果在使用赋值操作符时，左操作数是允许自动类型转换的，那么该操作数将会被类型转换并且赋予一个新的临时变量结果，当赋值操作结束时，该结果将无法访问。所以，所有复合赋值操作符都需要是类的成员操作符。这一段的意思仍然让人不太理解，待之后研究。

#### Chapter Thirteen

​	C++中的继承概念和Java是基本一致的，其声明是Kotlin形式的（明明是我先。。）：

```c++
class SubClass: [限定修饰符] SuperClass{ //...
```

其中限定修饰符指定了子类继承过来成员的最高访问权限，如果是public，则权限不变，否则超出该权限的成员访问权限应相应下调——如在protected下原本为public的成员变量也得变成protected，以此类推；

| 类型        | 命名规范                               |
| --------- | ---------------------------------- |
| 类库或程序库    | 名字前加一到两个字母的前缀                      |
| 方法名       | 驼峰式命名                              |
| 成员变量      | 以m开头的驼峰式(mVar)                     |
| 方法参数      | 首字母小写的驼峰式 (paramsType)             |
| 局部变量      | 下划线式命名法(var_name)                  |
| 指针变量      | 以p开头的驼峰式，*号接近变量类型(String\* pPoint) |
| 引用变量      | 以r开头的驼峰式(rRefrenceVar)             |
| 全局变量      | 以 g/g_ 为前缀的驼峰式(gGlobalVar)         |
| 静态变量      | 以s开头的驼峰式(sStaticVar)               |
| typedef命名 | 驼峰式 + Type为后缀(CoustomType)         |
| C函数的命名    | 下划线式命名法(get_the_num)               |



#### 附 [官方文档](http://www.cplusplus.com/reference)