## 关于组件化

一直以来似乎经常无故把**组件化**理解为**插件化**，想着动态加载dex什么的感觉好麻烦，就一直搁着。然后戳进[一篇文章](https://juejin.im/post/6881116198889586701)突然意识到有点不对，于是还是得记一下。

###组件化的含义

同插件化这种以动态加载代码为目的的方式不同，组件化指的是架构意义上的**模块划分与去耦合**。故应用的组件化更类似于后端的**微服务**，以业务为划分的组件相互之间不存在依赖关系，通过接口和共同依赖的路由框架进行调用。

###组件化对gradle的依赖

组件化的意义之一是让不同的开发者能专注于单独的模块进行开发和调试，意味着组件是可以单独运行的，而最方便的运行单位是application，于是这里就关系到gradle的动态配置——通过读取相关的配置文件（文中是gradle.properties，我觉得在根build.gradle中配置ext属性似乎也可以），让作为AndroidLib的组件能够转变为Application。

另外一点是，为了满足组件在项目结构上完全独立（即不同组件的代码也不在一个工程里）的目的，主App模块对组件的调用方式是依赖aar，这里需要配置组件本身的远程maven仓库版本配置。

###项目代码拆开了，然后呢？

正如单工程模块划分带来的会代码调用问题，组件化划分之后，页面间的路由、通信怎么办呢？这个问题的解决没有任何新意，同在《架构整洁之道》里看到过一万遍的写法一样，所有依赖问题都可以用接口和注入解决。

文章中使用的**路由**解决方案是借助**ARouter**，虽然我没看过它的源码，但我很怀疑它就是靠收集注解信息在编译时维护了一张所有页面的引用表，毕竟Activity跳转是一个只需要Class就能实现的活，都不用像EventBus一样动态注册和解注册来持有和释放对象。

> 说到这我觉得我明天干的活可以是手搓一个ARouter，不过手搓之前还是得看下为什么它不需要Context发起跳转的。

而关于**功能服务**的跨组件调用，文章中的解决方式是通过依赖通用接口，这也算是通用套路。不过和我最初想的提供一个统一的服务API模块不同，他们采用的是**每个组件分出需要暴露的接口单独作为一个模块**，理由是这样的话就不需要因为改变API模块影响所有的组件了，这倒也算不错。然后怎么注入调用方接口的实现对象呢？答案还是ARouter，这里的做法大概还是通过注解收集接口实现类，然后通过类名直接反射出一个对象（或许我可以试一下用Dagger？）。

这种方式在单模块调试的时候其实还是有些问题的，就是调用服务的时候依然不可避免的得起着被调用的服务（这里其实就是依赖被调用的模块），因为暴露接口模块最终还是需要得有对应的组件实现，所以调试的时候还是得手动直接依赖所需模块。

最后，关于模块所需依赖的初始化动作，其实我想着依然就是注册、分发的节奏，继续ARouter就完事了呗。然而他还真的整了点新东西，自己写了一个Application分发生命周期方法的插件。就是Application注册方法的写法感觉还是有点脏，于是我觉得这个我也要重新写一个（把注册方和分发方分成两个注解不好吗）。

###总结一下吧

发现前天才学会的Transform和字节码编辑还有更早之前的注解处理真的是被大家用烂了，很多看着挺高级的东西一下子没了神秘感。但组件化事实上真的就是模块化的更彻底版本（毕竟已经完全没办法显式调用了），它的难点在如今五花八门的工具和技巧下反而更倾向于gradle的优雅配置、远程仓库管理和业务本身的逻辑和范围分离。这本身不是一个技术问题，而更倾向于一个架构和工具化问题吧。