### 设计模式总结和整理

#### PartOne 六大基本原则：

#### 一、单一职责原则（SRP）

​	程序设计中应该将不同功能的方法分类放置，并且各类控制因素应该尽量少，甚至只存在单个控制因素能引起结果变化，避免耦合性过高，且程序臃肿。其最典型的应用在于各种**Util类的封装**以及**MVP**、**MVVM**等框架的职责划分。

#### 二、开闭原则（OCP）

​	程序维护和变化中应遵循**开放拓展，封闭修改**的原则，对于功能的增加和变化应更多地使用拓展的思路，主要方式即通过抽象，构造接口，然后创建新的功能类去实现，当无法理想地凭继承实现目的时，可以作源代码适量修改，特别是当源代码已不符合当前使用要求时，应该及早地抛弃，避免尾大不掉。该原则看似讲代码的维护，实际是对代码构造提出要求：在实现某个新的功能或需求时需要学会将其**特征抽象化形成接口或抽象类**，以便在将来更好地拓展和实现新的内容。

####三、里氏替换原则（LSP）

​	程序设计时，父类应能透明地利用子类的对象，即子类可以替代父类实现父类需要的功能，继而通过父类**隐藏子类对象的具体实现**。该原则主要强调的还是**抽象**这一概念，其实现核心仍是继承和多态。一方面要求父类的基本方法定义得全面、适用性强，另一方面也增加了子类的继承成本。

####四、依赖倒置原则（DIP）

​	程序设计中，调用方法时应依赖于抽象而非依赖于细节，即应尽量调用一个接口类或抽象类而非其实现类，并且实现类也应依赖于抽象类提供的基础方法。可知的是，当两个类间关系建立在细节上的时候，其耦合性就会过高，故该原则仍然强调抽象，减少类与类之间的直接耦合。

#### 五、接口隔离原则（ISP）

​	在实现接口时，应尽量避免实现不会被用到的接口方法，即接口最小化原则（甚至继承一个接口只实现一个函数），尽量少地因为不必要的接口方法暴露细节，并减少接口之间的联系，即**通过拆分降低耦合**。

#### 六、迪米特原则（LOD）

​	在功能实现类中应尽量建立单线通信方式，类只与有直接关系的类相关联，而其余更多的联系应该被剪断并分解至相应类中去，即终端类只需要知道结果，而把过程处理全部写在中继的类中。遵守该原则有利于不同定位的类直接的解耦，避免由于某个业务结点的改动影响到后继结点。**MVP**模式就是一个很好的利用该原则的例子。

___

#### PartTwo 设计模式介绍

#### 一、单例模式（源码解析部分：LayoutInflater）

​	为节省资源，让建立对象消耗较大的类只能存在一个实例，即**单例设计模式**。其实现方式有如下几种：

1. **饿汉式**：在类中自己创建一个 static final的实例，并把构造函数私有化，开放一个static方法来获取该实例；
2. **懒汉式**：私有化构造函数，创建一个static参数，通过静态方法增加判断语句，当该参数不为空，即第一次初始化的时候创建该类实例赋给该静态参数，返回该参数。但注意该方式静态方法需要是synchronized为前缀的同步方法，创建实例的时候较占用资源，不提倡使用；
3. **DCL模式**：同样是私有化构造函数，并在类内创建静态对象，但开放的静态方法中利用synchronized做线程锁（相当于一个判断条件），由于外部还有一个非空判断过程，就免去了每一次都要进行线程同步判断，同时线程锁后还有一个非空判断过程，保证不会有线程在第一个非空判断和线程锁之间挂起导致创建第二个实例。但其在JDK1.5之前有缺陷，即初始化过程和引用分配过程是乱序的，会导致初始化过程还未结束就会有其他线程将其实例取走而发生异常。JDK1.5之后，只要在创建的实例前加前缀volatile就可以保证其能安全初始化。DLC模式应用最为广泛，但同时由于JVM原因可能会在多并发线程情况下失败，称DLC失效。
4. **静态内部类模式**：同样私有化构造函数，且创建一个静态内部类，在内部类中创建private static final的实例对象，再开放一个静态方法返回该对象，该方式为单例模式的推荐方式。
5. **枚举（enumerate）**：枚举本身的性质就决定了它是单例的，且可以定义其自身的方法和成员变量，而且枚举**无法被反序列化创建实例**，注意其创建时要先声明实例对象，再写构造函数（只能为private），接着声明普通方法和成员变量。
6. 用**容器实现单例模式**：其实即创造一个管理类，用Map以键值对形式存和取不同类的实例对象，这样便于集中管理，且便于获得，降低了耦合度。

在Android中，**LayoutInflater**等服务的获取是典型的对单例模式的应用，它的实例通过Context子类ContextImpl的getSystemService方法得到，（Context存在一个注册了许多Service的HashMap，是一个典型的单例容器）其实际为一个PhoneInflater对象，调用inflate方法后会将视图设置在为Window在Activity的子类实现，即PhoneWindow所设定的区域中，并且在过程中进行解析，中间针对每个View都会用createView保留其参数即构造方法（对系统定义的View还会为其补全路径），先从xml文件根部标签开始，利用rInflate函数进行递归遍历，从深到浅解析完整个视图树，最后用setContentView方法交给Window来进行绘制。

**单例的缺点**：1.不利于接口拓展。2.如果一个单例类持有Activity的Context，易发生内存泄漏。



#### 二、Builder模式（源码解析部分：WindowManager）

​	基本原则即**将一个复杂对象的构造过程进行拆分**，拆分为**抽象类Builder**、**实现类ConrecteBuilder**和**组建类Director**。由Builder定义对象的属性和细节，ConrecteBuilder来具体实现不同对象的属性定义，Director来进行拼装和生成对象（即具体调用Builder以及最后的build或create方法）。该设计模式避免一个对象过多的调用函数赋予属性，将部件的构造和整体的拼装有效地分离，使代码具有整体性且清晰，其一个明显标识即Builder的**链式结构**。

​	Android源码中的一个典型Builder应用即AlterDialog，在这里Builder实现了该模式三个部分的所有功能，即既进行了参数设定，同时也以create()方法构建了AlterDialog对象。当AlterDialog创建完毕，调用show()方法时，即会进入一个类似Activity的生命周期流程，从onCreate开始，调用setContentView()设置其默认视图和用户定义视图，由Window层以下的部分完成绘制。

​	**WindowManager** 在View显示的过程中起到了重要的作用，其在表层得到的方式为Context调用getSystemService，在得到WMS对象之后，控件可以通过构造函数得到的Context新建**Window**并且通过setWindowManager将其与WindowManager对象绑定，而这个函数会新建一个WindowManager(通过调用**WindowManagerImpl**类中的函数)，而WindowManagerImpl也并不提供基础的功能函数，其函数都是对**WindowManagerGlobal**内函数的调用。而在其函数中**Handler的子类ViewRootImpl**起到了沟通Framwork层和Native层的作用，其构造函数中建立了一个**WindowSession**，它的来源是一个WindowManagerService的openSession函数，而该WindowManagerService来自于更底层ServiceManager的getService()，该函数通过**Binder**的方式获得了一个WMS对象。于是，通过ViewRootImpl对WMS发起请求，最后会触发**performTraversals()**函数，开始获取当前窗口的**surface，performMesure、performLayout、performDraw**(可选择用GPU或是软件方式绘图)，然后通知**SurfaceFlinger**更新界面。



#### 三、原型模式（源码解析部分：Intent的分发）

​	该模式简单来说就是通过**clone()**方法来对对象或者数据进行保护性拷贝或者以拷贝代替构造的形式来节省内存和运行开销。需要注意的是clone()方法的实现方式是一个native实现，不会调用对象类型的构造方法，且该对象类型必须实现**Cloneable**接口。而对象内的成员变量值最好各自调用clone()进行深拷贝，避免拷贝对象与原型相互关联。

​	在Android中，Intent也实现了这个接口，但其clone()方式不是通过对super.clone()的调用，而是构造一个新的Intent对象，并将其所带参数一一重新复制构造并传入，而该种方式的产生也是为了权衡构造一个新对象和底层拷贝的成本。

​	