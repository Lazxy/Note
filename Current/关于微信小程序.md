### 关于微信小程序

####基本结构

- 小程序**文件四件套**：**.json** 配置文件，有全局和页面的文件；**.wxml** 模板样式文件，类似Android xml，天然支持数据绑定；**.wxss** 微信版CSS文件，用来声明具体样式，比标准CSS多了一个长度单位`rpx`；**.js** 就是普通的JS文件，用来为wxml文件中绑定的控件设置交互逻辑和数据。
- 小程序的**分层结构**与常规Web页面不同，其页面渲染和逻辑执行是分为两个线程执行的（**Webview**线程与**JsCore**线程），两者通过**Native**层——即微信客户端来进行交互（也包括逻辑层执行网络请求）。一个小程序中每个页面都有其自己的一个Webview线程，但JsCore线程是共用的一个。
- **页面相关**：
  - 和Flutter声明资源类似的，小程序的页面也是需要列举声明在配置文件中的（app.json 的 `pages`字段），这个列表中的第一个参数即为小程序的首页。
  - 小程序有一个唯一的**APP**对象，声明在全局js文件里（即app.js），可以通过**onLaunch**回调来初始化小程序启动后的行为，同时还有**onHide**和**onShow**回调用以处理小程序进入后台状态和进入前台状态的动作。其中onLaunch和onShow方法允许带参数，来表示小程序打开的场景（来自别的小程序、扫码或者公众号等）和相关数值。
  - 每个页面有一个**Page**对象，可以通过**onLoad**回调来执行页面渲染完后的操作，同时还有onReady、onShow、onHide、onUnload等回调，对应Android Activity的onStart到onDestroy生命周期。类比中有些不同的是onReady只在一个生命周期中调用一次，且调用顺序晚于onShow（和onStart可被多次回调且调用早于onResume不一致）。
  - 页面的**加载顺序**是这样的：根据.json文件设置页面的初始信息（标题、导航栏等）->根据.wxml和.wxss来渲染基本页面结构 -> 加载.js文件 执行onLoad回调。



#### 开发相关

- wxml的标签必须是封闭的，其属性写在第一个标签的<>内，写法类似HTML的标签。

- wxml控件的数据绑定用`{{}}`声明，其内语句写法和Databinding写法基本上差不多，不过还支持直接输出数组。

- 可以用`wx:if="{{condition}}`、`wx:elseif="{{condition}}`、`wx:else="{{condition}}`来判断是否展示当前控件，其作用等效于Android的`android:visibility="{condition?View.VISIBLE:View.GONE}"`。如果需要对整块区域的多控件使用这个属性，则可以将那些控件写在一个`<block>`标签内。

- 与上面相应的，可以用`wx:for`来重复渲染一个列表的控件，用法如：

  ```html
  <!--如果这里不设置wx:for-index和wx:for-item属性，则默认为index（表示当前数据在数组的第几个）和item（数组中的当前数据对象）-->
  <view wx:for="{{array}}" wx:for-index="idx" wx:for-item="itemName">
    {{idx}}: {{itemName.message}}
  </view>
  ```

- 可以用`<template>`标签声明一个模板（类似Android xml的\<include\>），并给它的`name`参数赋值，在使用时，同样使用该标签，但传给`is`参数以之前的name值，如果还有相关数据，可以用`data`参数传入，即可调用该模板。`is`的参数可以是动态的。

  ```html
  <!--声明模板-->
  <template name = "temp">
  	<view>
  	<!--模板内容-->
  	</view>
  </template>
  
  <!--使用模板-->
  <template is = "temp" data = "{{params}}"/>
  ```

- 模板是可以通过引用定义该模板的wxml文件来在其他wxml文件中使用的，用`<import src = "XXX.wxml">`语法来实现；当需要引用整个wxml文件时，则可以用`<include src="XXX.wxml">`语法实现，相当于将那个文件中除了template的代码完全复制过来（但页面内使用的template样式实际上还是生效的），这里的意义与Android xml的\<include\>标签完全一致。

  > 注意如果是引用其他目录的布局文件，比如在/pages/pageFirst/pageFirst.wxml中引用/pages/pageSecond/pageSecond.wxml这里的文件目录写法是"../pageSecond/pageSecond.wxml"，`..`的作用是回到`pages`根目录。

- 可以通过require(path)引入其他js文件的单一模块方法，或者获取整个js模块的对象，一一单独调用模块中的方法。前者的定义是设置模块的暴露匿名方法，如：

  ```javascript
  //a.js
  module.export = function(value){...}
  
  var func = require("../a.js");
  func(1);
  ```

  而后者的定义是在定义方法时添加`export`关键字：

  ```javascript
  export function doSomething (value){...}
  
  require("../a.js").doSomething(1);
  ```

- **js的加载顺序**是这样的：最先加载的一定是app.js，然后按照app.json的`pages`定义的页面顺序，依次加载各js文件。在这当中，如果有require语句，则会提前加载require要求加载的js文件。

- 小程序中**js变量和方法的作用范围**仅在本文件内，需要使用全局变量时，需要通过**getApp()**方法来获取App对象，对它的属性进行赋值和取值。

- **Page之间的跳转**依靠`wx.navigateTo(url)`方法，url可以通过拼接query参数的方式来传递参数到Page构造器，Page构造器中则通过option对象取出对应名字的参数。小程序的页面栈最大层级为10级，除了navigateTo方法之外，还可以用`redirectTo(url)`方法完成对当前页面的替换，以及用`navagateBack()`进行出栈。

- **setData**方法本身是一个异步方法，所以其第二个参数是setData完成页面渲染后的回调。在setData时，只需要提供需要修改的参数键值对可一个修改某个或者部分参数，而不需要提供整个对象的所有参数；同时，键值对的键允许采用数据路径形式，如：

  ```js
  // page.js
  Page({
    data: {
      a: 1, b: 2, c: 3,
      d: [1, {text: 'Hello'}, 3, 4]
    }
    onLoad: function(){
      // a需要变化时，只需要setData设置a字段即可
      this.setData({a : 2})
  	//允许通过引用的方式来确定要修改数据的键
  	this.setData({"d[0]": 100}); this.setData({"d[1].text": 'Goodbye'});
    }
  })
  ```

- setData的属性值不能是undefined。

- 对于控件的事件监听，可以用bind\* 或者 catch\*后跟事件名来设置其监听方法参数，或者写作`bind:*`或`catch:*`。同时，在这两者前加`capture-`前缀可以表示添加捕获阶段的监听。

  > 对于上面的说法，有一些概念需要强调：**捕获阶段**和**冒泡阶段**表示事件的触发前和触发后的两个阶段，故带`capture-`前缀的监听触发一定比正常的监听早。
  >
  > 另外bind和catch的区别在于bind只进行监听，不影响事件本身的传递；而catch更类似于Android中的事件消费概念，消费完毕后事件就不会再往上层传递。

- **关于Flex**，Flex分为容器属性与项目属性，前者作用于容器下的项目排列规则，后者作用于项目自身的排列规则。列举如下：

  ```css
  /*容器属性*/
  display:flex;
  /*排列方式*/
  flex-direction:row（默认值） | row-reverse | column |column-reverse
  /*排满后是否允许换行*/
  flex-wrap:nowrap（默认值） | wrap | wrap-reverse
  /*项目主方向排列对齐方式 左对齐 右对齐 等间距均分等*/
  justify-content:flex-start（默认值） | flex-end | center |space-between | space-around | space-evenly
  /*项目本身对齐方式，类似于LinearLayout的gravity效果*/
  align-items:stretch（默认值） | center  | flex-end | baseline | flex-start
  /*项目交错方向的对齐方式 值的含义同justify-content*/
  align-content:stretch（默认值） | flex-start | center |flex-end | space-between | space-around | space-evenly
  ```

  ```css
  /*项目属性*/
  /*表示项目在布局中的排列顺序，数字越大越靠后*/
  order:0（默认值） | <integer>
  /*表示项目在布局空间不足时的压缩比例，如果全都是1的情况下所有控件都会按相同比例缩小*/
  flex-shrink:1（默认值） | <number>
  /*表示项目在布局空间空余时的拓展权重*/
  flex-grow:0（默认值） | <number>
  /*表示布局的默认主方向尺寸大小，优先级高于width/height，除非width/height有确定值而该属性值为auto*/
  flex-basis:auto（默认值） | <length>
  /*上面三个属性的简写形式，当为none时是0,0,auto 为auto时是1,1,auto*/
  flex:none | auto | @flex-grow @flex-shrink @flex-basis
  /*用以控制项目自身对齐方式的属性，会覆盖align-item属性，auto表示继承align-item属性*/
  align-self:auto（默认值） | flex-start | flex-end |center | baseline| stretch
  ```

- **关于小程序中的网络请求**，小程序提供了API `wx.request({url,method,data,header,dataType,success,fail,complete})`，可以自行设置请求地址、请求方法、请求数据（post请求中），请求头，请求返回值类型，请求回调等属性。使用get方法请求时，url长度最大为1024byte，超过该长度时需要使用post请求。设置请求的超时时间需要在.json文件中设置`networkTimeout`参数。

- 小程序的读取本地缓存方法是`wx.getStorage/wx.getStorageSync(key)`，设置本地缓存的方法则为`wx.setStorage/wx.setStorageSync(key,data)`，带`Sync`后缀表示该方法会同步返回结果，而不带后缀的方法需要在回调中接收调用结果。**本地缓存的上限为10MB**。


