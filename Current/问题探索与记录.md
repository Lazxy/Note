> 记录一些偶然性遇到的问题，篇幅不足以来一篇完整的记录，只记下一些关键性代码，仅作为再次遇到问题时的简单索引。

1. **ScrollView**中嵌套**RecyclerView时RecyclerView**不可见的问题。

   关键代码段一：

   ```java
   //FramLayout中的onMeasure关于子View测量大小的片段
   for (int i = 0; i < count; i++) {
   	final View child = getChildAt(i);
   	if (mMeasureAllChildren || child.getVisibility() != GONE) {
   	//Highlight
       measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0);
       //Hightlight
       final LayoutParams lp = (LayoutParams) child.getLayoutParams();
       maxWidth = Math.max(maxWidth,child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);
       maxHeight = Math.max(maxHeight,child.getMeasuredHeight() + lp.topMargin + 				                 lp.bottomMargin);
       childState = combineMeasuredStates(childState, child.getMeasuredState());
       if (measureMatchParentChildren) {
            if (lp.width == LayoutParams.MATCH_PARENT ||
               lp.height == LayoutParams.MATCH_PARENT) {
               mMatchParentChildren.add(child);
               }
            }
       }
   }
   ```

   关键代码段二：

   ```java
   //ScrollView中重写的measureChildWithMargins方法
   protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed,int parentHeightMeasureSpec, int heightUsed) {
           final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();

           final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,
                   mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin
                           + widthUsed, lp.width);
           //Highlight
           final int childHeightMeasureSpec = MeasureSpec.makeSafeMeasureSpec(
                   MeasureSpec.getSize(parentHeightMeasureSpec), MeasureSpec.UNSPECIFIED);
   		//HighLight
           child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
       }
   ```

   关键代码段三：

   ```java
   //RecyclerView中的defaultOnMeasure方法
   private void defaultOnMeasure(int widthSpec, int heightSpec) {
           final int heightMode = MeasureSpec.getMode(heightSpec);
           final int heightSize = MeasureSpec.getSize(heightSpec);
         	//...
           int height = 0;
           //...
           //Highlight
           switch (heightMode) {
               case MeasureSpec.EXACTLY:
               case MeasureSpec.AT_MOST:
                   height = heightSize;
                   break;
               case MeasureSpec.UNSPECIFIED:
               default:
                   height = ViewCompat.getMinimumHeight(this);
                   break;
           }
   		//Highllight
           setMeasuredDimension(width, height);
       }
   ```

   分析：在ScrollView进行onMeasure的时候，会先调用父类的onMeasure，即FrameLayout的onMeasure，但在这个方法执行的过程中，会去调用measureChildWithMargin方法，此时进入的是ScrollView的重写方法，而其对于width的处理与父类实现相同（对WRAP_CONTENT和MATCH_PARENT都赋ViewGroup的最大值），但**对height的处理为统一设为UNSPECIFIED**，而根据RecyclerView的onMeasure方法，当其大小类型为UNSPECIFIED时，其值为最小大小值，**默认为0**。故RecyclerView不会在ScrollView中显示。

   解决：这里的解决方式有两种，一、通过设置minHeight值，理由上面已经提到过。

   二、设置fillViewPort值为true，这样一来，即使在super.onMeasure中设置的高度为默认最小高度的0，在ScrollView的重写实现中，还有重新测量的机会，关键代码如下：

   ```java
   //ScrollView的onMeasure实现
   protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec){ super.onMeasure(widthMeasureSpec, heightMeasureSpec);
     //Highlight  
     if (!mFillViewport) {
                 return;
             }
     //Highlight
     final int heightMode = MeasureSpec.getMode(heightMeasureSpec);
        if (heightMode == MeasureSpec.UNSPECIFIED) {
              return;
        }

        if (getChildCount() > 0) {
        final View child = getChildAt(0);
        final int height = getMeasuredHeight();
           if (child.getMeasuredHeight() < height) {
              final int widthPadding;
              final int heightPadding;
              final FrameLayout.LayoutParams lp = (LayoutParams)child.getLayoutParams();
              final int targetSdkVersion = getContext().getApplicationInfo().targetSdkVersion;
              if (targetSdkVersion >= VERSION_CODES.M) {
                 //...
                 heightPadding = mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin;
              } else {
                      //...
                      heightPadding = mPaddingTop + mPaddingBottom;
              }
              //...
              //Highlight
              final int childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(height - heightPadding, MeasureSpec.EXACTLY);
               child.measure(childWidthMeasureSpec, childHeightMeasureSpec);
             //Highlight
         }
      }
   }
   ```

   当fillViewPort为true时，ScrollView会尝试将RecyclerView的高度设置成填满ScrollView的高度，此时给的大小类型为EXACTLY，于是RecyclerView就能得到足够的空间进行绘制了。

   后续：发现UNSUPCIFIED似乎并不是出问题的原因，在**教新版本（>23.0.1）**的RecyclerView在上面的过程后，还会去在布局后测量每一个子View的大小，并将它们加入到高宽的设定中来，代码如下：

   ```java
   //预布局后补充子类高宽的参数
   void setMeasuredDimensionFromChildren(int widthSpec, int heightSpec) {
               final int count = getChildCount();
               if (count == 0) {
                   mRecyclerView.defaultOnMeasure(widthSpec, heightSpec);
                   return;
               }
   			//...
               for (int i = 0; i < count; i++) {
                   View child = getChildAt(i);
                   LayoutParams lp = (LayoutParams) child.getLayoutParams();
                   final Rect bounds = mRecyclerView.mTempRect;
                   getDecoratedBoundsWithMargins(child, bounds);
                   if (bounds.left < minX) {
                       minX = bounds.left;
                   }
                   if (bounds.right > maxX) {
                       maxX = bounds.right;
                   }
                   if (bounds.top < minY) {
                       minY = bounds.top;
                   }
                   if (bounds.bottom > maxY) {
                       maxY = bounds.bottom;
                   }
               }
               mRecyclerView.mTempRect.set(minX, minY, maxX, maxY);
               setMeasuredDimension(mRecyclerView.mTempRect, widthSpec, heightSpec);
           }
   //重填RecyclerView的宽高参数
   public void setMeasuredDimension(Rect childrenBounds, int wSpec, int hSpec) {
               int usedWidth = childrenBounds.width() + getPaddingLeft() + getPaddingRight();
               int usedHeight = childrenBounds.height() + getPaddingTop() + getPaddingBottom();
               int width = chooseSize(wSpec, usedWidth, getMinimumWidth());
               int height = chooseSize(hSpec, usedHeight, getMinimumHeight());
               setMeasuredDimension(width, height);
           }
   ```

   ​

2. #### 关于换肤原理

   ​	在AppCompatActivity中，setContent方法的实际实现交给了AppCompatDelegate（根据不同的版本会有不同的实现类），而该类在初始化时会对LayoutInflater的Factory进行设置（实际上就是把Factory设置为Delegate本身），其决定了inflate方法中crateViewFromTag的实际实现。故只要将AppCompatDelegate实现类替换（这里同时也得重写AppCompatActivity的getDelegate方法），就可以通过Factory控制控件的生成（如AppCompat系列组件对原生组件的替换），在自定义的替换控件内提取出自定义的主题属性并加以设置，从而达到主题控制的目的。

3. #### 关于ViewPager

   ​	ViewPager的实现其实是利用一个滚动布局将有限个页面横向放置在一起，从而达到无缝连接和重复加载的效果。

   ​	用mItems 存放了所有在Adapter中构造出来的View对象，并且存放了相应的位置信息，提供复用；

   ​	在**populate()**方法中实现了预加载与当前界面的生成和销毁，每个页面占据宽度的计算，以及其绘制顺序的确定（**先按position绘制内容页面，再绘制isDecro == true的装饰性控件**），是页面切换的主要方法。

   ​	比较有意思的一个点是，Viewpager的`setChildrenDrawingOrderEnabledCompat`里居然用了反射的方法调用ViewGroup的`setChildrenDrawingOrderEnabled`方法，同时重写`getChildDrawingOrder`方法完成了逆序绘制各个Pager的功能要求。

   ​	**onPageScrolled**回调方法会在**pageScrolled**中调用，而**completeScroll**才是真正的发起者。

   ​	`isGutterDrag`方法用于判断当前页面是否处于松手就会复位的状态。

   ​	**onInterceptTouchEvent**中操控了如下细节：1. ViewPager自带的横向滑动判断条件是滑动距离大于`mTouchSlop`且横向滑动大于纵向滑动的两倍（在onTouchEvent中又变成一倍了）。2. 当在自然滚动中再次进行`DOWN`动作时，滚动动画中断，并继续回到`dragged`状态。​

4. ####关于RecyclerView

