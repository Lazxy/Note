图的两种不同的数据结构和搜索方法
     一、深度优先搜索：类比于走迷宫，在图的构建过程中，从根结点出发，通过其相邻结点进行递归遍历，并在每个结点（迷宫的拐角）处做已遍历标记（通常是存在一个boolean数组中，角标即结点的标记），遇到已标记的相邻结点时便忽略重复结点（在迷宫中走了重复的道路，回头寻找其他方向）。这种遍历方法会使图的构建先以一颗长树干的方式伸展（中间经历较短的岔路），接着再将枝和叶遍历完全。
    在此基础上，可以通过一个数组保存结点的连接路径，角标为结点标记值，值为该结点的在树构建时的上一个结点。这样一来，从目标结点开始不断访问这个路径数组（每一次访问的结果都是该结点在路径上的上一个结点），就可以得到根节点是否与目标结点相连，以及其相连的完整路径了。

     二、广度有限搜索：这种构建图的方法中较前面的方法多了一个队列，策略为从根结点开始，先取得未被标记过的相邻结点加入队列，并将它们标记后，路径存入数组（和上面相同），接着队列出列一个结点，以同样的方式取得未标记的相邻结点加入队列，重复以上操作，直到队列中的所有值都出列。其树的生长方式相当于围绕着根结点一步步向四周伸展枝叶，并且由于FIFO特性，其获得的结点间路径必定是最短的。

有向图暂略。。大部分应用算法为深度优先搜索，剩下的。。太难了。

最小生成树：指在一张有权无向图中，在恰好满足组树条件（即多一条边成环，少一条边成两棵树）下权值最小的生成树。
最小生成树算法原理：先由切分定理――即任意划分的两组顶点的最小横切边（跨越两组顶点的边）必定是最小生成树的边之一。

生成最小生成树的算法：
一、Prim算法：该算法主要思想是每搜索一个结点的相邻结点时，都维护一个关于边的权值的优先队列，在结束对所有邻居结点的遍历后，便将优先队列中的最小值作为新的结点相连，然后重复这个过程，忽略已经加入树的结点。根据该优先队列的操作方法的不同，可以分为延迟型和即时型两种Prim算法。前者会将所有遍历过程中的所有结点全部入列，而后者会保存最小值，每次将其取出同其他边的权值进行比较，直到遇到更小的边时才替换该结点入列。

二、Kruskal算法：该算法的主要思想是先对所有结点的边排序，然后从小到大依次尝试连接每个结点，忽略已经被连接过的结点，以此直到构成一颗V-1条边的树。

最短路径算法：
一、Dijkstra算法：用于加权有向图的最短路径算法。其主要基于最优性条件――当且仅当s->w的某一条路径比所有s->v + v->w的路径都更短时，s-w的路径最短。根据该条件，该算法维护了一个优先队列，从根结点开始，遍历其相邻结点，并检查这些结点是否满足优先条件，若满足则连同路径长一同加入优先队列，或者更新队列中的值，其后循环将队列中的最短路径出列，继续遍历相邻结点。在初始状态下除了s（即根结点）->s的距离为0，s到任意结点的距离都为无限大，故最开始s->任意结点的距离都会被视为最短距离，其后在最优性条件约束下会逐步被更新，这种情况类似于Prim算法，每次添加一条最短边作为新的边，但此时“最短边”应替换为“到已有的s生成链的最短路径”，其拓展方向是始终均衡向外的。到最后，当所有结点都满足最优性条件或者所有结点都被遍历到时，整个探路过程结束，保存顶点到各结点最短路径的数组就是需要的最短路径数据。

二、拓扑排序最短路径算法：其原理为当以拓扑排序顺序relax每个结点时，每个结点v的路径长度已经确定（无环图），而其下一个结点w的路径长度根据最优性条件将会是逐渐减小的，直到确定为最小。然后w一定会是拓扑中的下一个点之一，故如此遍历下去，可以最终得到一条全路径满足最优性条件的路径。（这种条件下求最长路径只需要将所有边的权值设为其相反数再求最短路径，或者改变最优性条件的不等式方向即可。）


