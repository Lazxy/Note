基本排序算法：
①选择排序，即在循环中遍历N-1次数组，依次选择出最小值排在最前面。该算法的比较次数大概是二分之N平方次，其特点为前面的循环过程对后续的排序无帮助，故实际输入数据与输出无关，且其交换次数是线性级别的，在排序算法中最少。


②插入排序，与选择排序不同，其遍历数组的过程中，每次遇到倒置的对象就开启一次排序过程(以升序排序为例，从第一个数开始移动当前数标志，如果后面的数小于当前数，则将这个较小数与前面的数一一比较，寻找到其位置插入，直到当前数移动到最后一个数)。该算法的比较和交换位置的复杂度一般条件下都是平方级别的，但在有序条件下会是线性级别的(此时交换次数为0)，当数组倒置的情况小于一定值，即部分有序时，其表现好于选择排序。


进阶排序算法:

①希尔排序。其理论基础为先排间隔较大的数据再排间隔较小的数据可以减小由于数据随机性带来的比较次数较多的问题(在间隔较远的位置出现倒置的数据会造成前半部分的大面积重排比较)。其实质仍是用插值排序，但排序过程中遵循某种增长序列(如3∧k + 1,即 1 4 13 40 121…)，具体为:一、根据数组大小N确定增长序列;二、进行“h有序”排序，即将若干个间隔为h的数组成的数组进行排序(如对一个16个数的数组，可以得到13 4 1这组增长序列，h=13时，仅有0与13这一组数组，而h=4时，有{0 4 8 12}  {1 5 9 13} {2 6 10 14} {3 7 11 15}这四组，可以分别排序为有序数组)。三、经过前几轮数组排序，最后都会回到h=1的情况，此时相当于进行正常的插入排序，但此时相当于输入数据为一个有序数据，能够大大减小开销。



②归并排序。其理论出发点跟希尔排序有些类似，也是通过不相邻数的排序来减少插入排序开销。其实现方式具体为:一、将整个数组分为两个有序数组(在例子中形成有序数组的方式是用递归的方式不断分割数组长度，从两个数的数组排序开始返回值，逐渐排完整个分数组，中间也包括了归并过程，类似FFT中分割复杂复数乘法至加法的原理)。二、进行归并操作(具体过程为对源数组进行复制，得到辅助数组，分别设置其前半部分和后半部分的起始角标，然后比较两部分同位置数的大小，将较小值赋值给源数组的前部分，其所属组角标自增，再重复比较，直到角标溢出，则将另一组剩余数据添加入源数组，归并完成，排序也一并完成。)可计算得到，归并排序的比较次数在1/2NLog2N到NLog2N之间，而数组访问次数小于6NLog2N。
另外，除了上述利用递归的自顶向下的归并排序方法，还有一种利用循环的自底向上的归并排序法。其基本思路为先一对对地将数据排序，遍历一遍整个数组，然后将数据的比较量加倍(比如由原来的两两比较归并增长为四四比较归并)，再遍历一遍数组，如此到最后也实现了整个数组的排序(最后会剩下两个有序子数组，它们的长度可能不一致，但对归并无影响)。其复杂度基本跟上面的归并相同。


③快速排序。其算法思路是先对数组进行预处理，使数组围绕一个中间值分为两个子数组:左边的子数组都小于这个中间值，右边的子数组都大于这个中间值，这个过程叫做切分。切分的过程也很简单，即随机选取一个标准值，然后从数组两端向中间循环移动两个指针，当左边的指针指向一个大于该值的数时，记录其角标;当右边的指针指向一个小于该值的数时，也记下角标，然后交换两个数的位置，继续相向移动。循环的跳出条件是，两个指针相遇。此时将指针指向的最后一个值与标准值交换位置(此时这个值必定小于等于标准值)，于是完成了切分。切分完成后的过程仍然是递归调用排序，分别对左右两边的两个数组再次进行排序，待递归全部完成后，整个数组的排序便宣告完成。

快排在极端有序下切分相当于切分数组长度次，如果用递归排一个大数很可能栈溢出。


④三向切分的快速排序:适用于数组中含大量重复值的情况(当然在不重复的情况下跟一般的快速排序一致)。其主要思想就是将数组划分为三个区域——小于标准值的子数组、等于标准值的子数组和大于标准值的子数组，分别用三个指针lt,i,gt指明三个数组的下界+1、下界+1和上界-1。然后让i从左至右移动，当指向的数小于标准值时，交换lt和i的值，并两者同时加一（左边数组长度+1，推动中间数组右移一位）；当i指向的数大于标准值时，交换i和gt的值，同时gt-1（右边数组长度拓展1，中间数组不移动）；当i指向的数等于标准值时，则i+1继续移动(中间数组+1)。最后在i与gt交错而过时终止循环，并再继续递归地排序左半边数组和右半边数组。

三向切分快排在数组内并没有什么重复内容时会有大量无意义的交换过程，且交换的数量总是高于快排，所以速度经常比快排慢。

⑤堆排序。思路是先对任意的无序数组从最后一层根节点开始进行下沉操作，一直遍历到堆顶，此时构造的堆有序；接着依次将堆顶的值与最末尾的叶节点互换，再次下沉恢复堆的顺序（此时下沉操作不包括被置换的前堆顶节点）。一直重复到堆的节点只剩下根节点。此时由于最大节点依次被替换到堆底，所以最后数组会形成一个降序顺序，完成排序。
该算法的复杂度基本是线性对数级别的，在数组有序的情况下与选择排序相似。