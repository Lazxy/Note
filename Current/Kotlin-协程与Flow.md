## Kotlin-协程与Flow

### 协程回顾

- 两个启动参数 - 何时开始执行协程，协程执行在什么线程
- suspend和async - 阻塞式协程方法（挂起函数）标记，与非阻塞式协程方法标记（但最后也还是会阻塞在await方法）

### 关于Flow

- 和Sequence进行对比 （支持协程的Sequence？）

- Flow是冷流，只有在每次collect触发时，才会重新（完整地）触发一次Flow的发送 - 正因Flow本身是被动触发的，所以生成Flow的方法不会是一个suspend方法，因为如果生成Flow的方法都挂起了，那就没有人能触发它实际运行了

- Flow的运算符类似RxJava的Observable，只是进行了一层包装，实际触发效果还是在Flow的collect触发之后，所以运算符也是冷的

- Flow的取消是以异常实现的，所以流中存在try-catch-finally时 ，中断可能不会及时生效。（如果后续还进行emit的话，会直接抛出中断异常）

- Flow在大多数情况下，是串行执行的。即一个对象在emit后经过多个操作符时，如果能向下执行完毕，则会执行完所有操作符，才会继续下一个对象的过程。这和RxJava的一个操作符做完所有事情后执行下一个操作符不一样。

- Flow的Context有属地原则，一般遵循启用协程的Context对象；如果在Flow中使用其他Context发射流对象，会抛出异常。
  
  > 但真正需要修改Context时，可以在定义Flow的时候，使用flowOn(Dispatcher)方法来指定Flow所在协程。

- 使用buffer()操作符可以实现集合flow的并发操作——指Flow中如果出现emit语句，不进行挂起，而是缓存emit行为，最后集中进行collect分发。可以用这个操作符来处理emit之前有耗时行为的场景。

- 使用collectLatest可以只取当前Flow接收到的最新值。使用场景是collect行为中出现一些挂起方法时，新的值已经提前到达，那么挂起后旧值的后续代码都不会执行。

- combine和zip的区别：zip会忠实地一一对应多个流中的值，如一个流400ms发一次请求 另一个300ms发一次，则zip会每400ms发一次合并事件；而combine的规则是，每当任一流发生事件时，都拿当前事件和其他流的上一个事件组合发布一次，按照上面的例子，在1200ms时间内，300ms间隔的事件A会发四次请求，分别与400ms的事件B的第一个请求组合两次（400ms和600ms），第二个请求组合两次（800ms和900ms），第三个请求组合一次（1200ms）

- 如果出现一个Flow中嵌套着另一个Flow的情况（一个流的对象内容也是流），可以使用flatMapXXX方法进行展平处理，其中：
  
  - flatMapContract表示依次处理子流中的内容，处理完了之后才进行下一个父流的处理
  
  - flatMapMerge就完全摒弃父流的顺序，根据子流的事件触发，来进行处理。
  
  - flatMapLatest ,Merge规则时序，不过在子流的响应也进行限制，如果子流存在新值在挂起方法挂起时到了，那么旧值就不会再往下执行代码。

- flow{} 代码块对于异常是完全透明的（可以视作flow内部把异常原样抛了出来），代码块内出现异常时，在flow的调用者可以直接通过try-catch捕获到对应异常，或者用flow.catch()方法进行异常捕获。
  
  > 注意.catch方法完全遵循调用顺序，所以它不能捕获collect等terminal方法触发的异常。

- onComplete方法可以作为流结束的回调（如果是嵌套流，那就是父流完全结束的回调），其以cause参数为标志，非空时即为过程中出现了异常，但并不会进行捕获（相当于一个finally，不过调用在catch之前）

- collect实际上是一个挂起方法，所以代码执行到这，会阻塞住接下来的执行。如果需要既触发flow，又继续接下来的代码，可以用launchIn来将Flow运行在一个单独的协程里。

- 可以用onEach来进行Flow每一个请求执行前的监听

- flow中调用cancel可以进行流的中断，在中断后执行流会抛出异常。不过在某些预设的流方法中（比如IntRange的asFlow），不会检查中断标记位，中断可能无效。

- SharedFlow和StateFlow是热流，它们不用依靠collect进行每次流的启动（或者根据启动模式，只要启动一次即可）
